# Alumno: Calvo Moratilla, José Javier
# Profesor: Gómez Adrian, Jon Ander
# UPV - ETSINF
# 17-05-2021
# Ayuda al diagnóstico de cáncer de colon mediante aprendizaje automático.
# Programa para generar una máscara completa de las mascaras generadas por la red unet

#Libs
import numpy as np
import cv2
from tqdm import tqdm
import matplotlib.pyplot as plt 
import os, glob, re

#
#Folder that stores mask images generated by unet
#folder_input ='../data/paip2020/training/mask_img_unet_output_mini
folder_input = '../data/paip2020/training/mask_img_l3_mini/'

#Folder that stores mask l3 image generated by output from unet
folder_output ='../data/paip2020/training/mask_img_unet_output_l3/'

#sizes output, imagen original
h_ouput, w_ouput = (2827, 3859) #4000 #3000 #(3859, 2827)

#Imagen resultante
#outputImage = np.full((h_ouput, w_ouput), fill_value='zeros', dtype=np.uint8)
outputImage = np.zeros((h_ouput, w_ouput, 3), dtype=np.uint8)

#Buscar patron en el nombre del archivo
buscarShapes = re.compile('[_][0-9]*[_][0-9]*[.]')

#Obtain every name of data in input folder
list_tif = sorted(glob.glob(folder_input + '*.tif'))

# FUNCIÓN joinImage: 
# Se encarga de unir las mask resultantes de la red unet
# INPUTS
# Entrada --> Folder de dónde obtiene las imágenes para unir
# listaArx --> lista de archivos  
# extension --> Extensión del archivo de salida    
def joinImage(salida, listaArx, extension):    
    #se crean el directorio de salida, si no existe
    os.makedirs(salida, exist_ok=True)

    #Se recorren todos los archivos de esa carpeta y se guardan en img para ser recorridas y recortadas
    #Formato de entrada
    #nombreficheropadre_width_heigth.tif"

    for nombreImagenAbsoluto in tqdm(listaArx): 

        #se abre la imagen y se coloca un pad de 176x176 a 200x200
        #img = Ima ge.open(im) 
        
        #Buscar patron en el nombre
        shapes = buscarShapes.search(nombreImagenAbsoluto).group()
        
        #Se quitan las barras bajas para poder hacer split
        listShapes = re.sub("_", " ", shapes[0:-1]).split()      

           #se obtiene el desplazamiento horizontal y vertical de la imagen entrante
        origWidth = int(listShapes[1]) #col
        origHeight = int(listShapes[0]) #row  

        #EN CASO DE PAD  
        #img = np.pad(cv2.imread(nombreImagenAbsoluto),12)       
        img = cv2.imread(nombreImagenAbsoluto)
        
        #se obtienen el width, heigth correspondiente de la imagen
        height, width, _ = img.shape  

        #Se reconstruye la imagen grande
        outputImage[origHeight:origHeight+height, origWidth:origWidth+width] = np.maximum(outputImage[origHeight:origHeight+height, origWidth:origWidth+width], img[:,:])
        
    
    #Se recorre todo el diccionario y se genera el array resultado correspondiente
    #print('Start create output image')
    #for key in tqdm(indexPixels.keys()):
    #lista de valores de pixeles
        #valoresPixels = indexPixels[key]
        #cordY, cordX = key
        #outputImage[cordX, cordY] = np.average(valoresPixels)
    print('Finish create output image')  
    cv2.imwrite(folder_output + 'res_experimento.tif' , outputImage)  
    

#program
print('Starts Join proces')
joinImage(folder_output, list_tif, '.tif')
print('Join process ends')